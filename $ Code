# ai_sports_ev_bot.py

import requests
import pandas as pd
import numpy as np
import streamlit as st
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler

# --- CONFIG ---
API_KEY = "YOUR_ODDS_API_KEY"
SPORTS = ["basketball_nba", "football_nfl", "basketball_ncaab", "football_ncaaf", "baseball_mlb"]
TOP_BETS_COUNT = 5
STAKE = 1  # You can scale EV by your real bet stake

# --- FETCH ODDS DATA ---
def fetch_odds(sport):
    url = f"https://api.the-odds-api.com/v4/sports/{sport}/odds/"
    params = {
        "apiKey": API_KEY,
        "regions": "us",
        "markets": "h2h,spreads,totals",
        "oddsFormat": "decimal"
    }
    response = requests.get(url, params=params)
    return response.json()

# --- PREPROCESS DATA ---
def prepare_data(odds_data):
    rows = []
    for game in odds_data:
        if 'bookmakers' not in game or len(game['bookmakers']) == 0:
            continue
        for bookmaker in game['bookmakers']:
            for market in bookmaker['markets']:
                if market['key'] in ['h2h', 'spreads', 'totals']:
                    row = {
                        'home_team': game['home_team'],
                        'away_team': game['away_team'],
                        'market': market['key']
                    }
                    for outcome in market['outcomes']:
                        row[outcome['name']] = outcome.get('price', np.nan)
                    rows.append(row)
    df = pd.DataFrame(rows).dropna()
    return df

# --- FEATURE ENGINEERING ---
def feature_engineering(df):
    feature_cols = [col for col in df.columns if col not in ['home_team','away_team','market']]
    scaler = StandardScaler()
    df[feature_cols] = scaler.fit_transform(df[feature_cols])
    return df, feature_cols

# --- TRAIN ENSEMBLE MODEL ---
def train_model(df, feature_cols):
    X = df[feature_cols]
    # Mock target: pick home_team if odds lower than away_team (you should replace with historical results for real accuracy)
    y = (df[feature_cols[0]] < df[feature_cols[1]]).astype(int)
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    rf = RandomForestClassifier(n_estimators=100, random_state=42)
    xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)
    lr = LogisticRegression()
    
    rf.fit(X_train, y_train)
    xgb.fit(X_train, y_train)
    lr.fit(X_train, y_train)
    
    return rf, xgb, lr

# --- ENSEMBLE PREDICTIONS ---
def ensemble_predict(models, X):
    rf, xgb, lr = models
    pred_probs = (rf.predict_proba(X)[:,1] + xgb.predict_proba(X)[:,1] + lr.predict_proba(X)[:,1]) / 3
    return pred_probs

# --- CALCULATE EXPECTED VALUE (EV) ---
def calculate_ev(prob_win, odds, stake=STAKE):
    # Decimal odds assumed
    payout = (odds - 1) * stake
    ev = (prob_win * payout) - ((1 - prob_win) * stake)
    return ev

# --- STREAMLIT DASHBOARD ---
def main():
    st.title("AI Sports Betting Bot - Positive EV Bets")
    
    sport_choice = st.selectbox("Select Sport", SPORTS)
    
    st.write(f"Fetching odds for {sport_choice}...")
    odds_data = fetch_odds(sport_choice)
    
    df = prepare_data(odds_data)
    df, feature_cols = feature_engineering(df)
    
    st.write("Training ensemble model...")
    models = train_model(df, feature_cols)
    
    st.write("Generating predictions...")
    df['pred_win_prob'] = ensemble_predict(models, df[feature_cols])
    
    # Calculate EV for each outcome (home and away)
    ev_list = []
    for idx, row in df.iterrows():
        ev_outcomes = {}
        for col in feature_cols:
            ev_outcomes[col] = calculate_ev(row['pred_win_prob'], row[col], STAKE)
        ev_list.append(ev_outcomes)
    ev_df = pd.DataFrame(ev_list)
    
    df = pd.concat([df, ev_df.add_prefix('EV_')], axis=1)
    
    # Filter for positive EV bets
    positive_ev_cols = [c for c in df.columns if c.startswith('EV_')]
    df['max_EV'] = df[positive_ev_cols].max(axis=1)
    df['best_bet'] = df[positive_ev_cols].idxmax(axis=1).str.replace('EV_','')
    
    positive_ev_bets = df[df['max_EV'] > 0].copy()
    
    # Top 5 EV bets
    top_bets = positive_ev_bets.nlargest(TOP_BETS_COUNT, 'max_EV')
    
    st.subheader("Top 5 Most Profitable Bets (Positive EV)")
    st.dataframe(top_bets[['home_team','away_team','market','best_bet','max_EV','pred_win_prob'] + feature_cols])
    
    st.subheader("All Positive EV Bets")
    st.dataframe(positive_ev_bets[['home_team','away_team','market','best_bet','max_EV','pred_win_prob'] + feature_cols])
    
    # Console output
    print("Top 5 EV Bets:")
    print(top_bets[['home_team','away_team','market','best_bet','max_EV','pred_win_prob'] + feature_cols])

if __name__ == "__main__":
    main()
